# 리스트, 딕셔너리

## 리스트

* 순서대로 저장하는 시퀀스이자 변경가능한 목록을 말한다.
* 입력 순서가 유지되며 내부적으로는 동적 배열로 구현된다.
* 스택, 큐에서 사용 가능한 모든 연산을 함께 제공한다. -> 큐, 스택 사용을 고민하지 않아도 된다.

#### 리스트 활용

~~~
# 리스트 선언 
a = list()
a = []

# 초기값 지정 선언
a = [1,2,3]

# append 마지막에 값 삽입
a.append(4)   ## [1,2,3,4]

# insert 특정 위치의 인덱스에 값 삽입
a.insert(3, 5)  ## [1,2,3,5,4]

# 다양한 타입으로 값을 삽입할 수 있다.
a.append('안녕')
a.append(True)
a  ## [1,2,3,5,4, '안녕', True]

# 슬라이싱 기능: 특정 범위 내의 값을 매우 편리하게 가져오는 방법
a[1:3]  ### [2, 3]

## 시작 인덱스 생략
a[:3]  ### [1,2,3]

## 종료 인덱스 생략
a[4:]  ### [4, '안녕', True]

## 세 번재 파라미터: 몇칸씩 건너뛰게 된다.
a[1:4:2]  ### [2, 5] -> 2칸씩 건너뛰게 된다. -> 홀, 짝 구분해서 출력할 때 용이

# 인덱스 범위 넘을 경우 예외처리
try:
  print(a[9])
except IndexError:
  print('존재하지 않는 인덱스')

# 리스트에서 요소 삭제하는 2가지 방법
## 1. 인덱스로 삭제하기 -> del 키워드
del a[1]  ### [1,2,3,5,4,'안녕', True]

## 2. 값으로 삭제하기 -> remove 함수
a.remove(3)  ### [1,5,4,'안녕', True]

#pop 함수-> 삭제될 값을 리턴하고 삭제가 진행된다.
a.pop(3)  ## '안녕'
~~~

### 리스트의 특징

* 리스트는 객체로 되어 있는 모든 자료형을 포인터로 연결한다.
* 연속된 공간에 요소를 배치하는 배열의 장점과 다양한 타입을 연결해 배치하는 연결 리스트의 장점을 모두 취함
* 자료형의 크기는 모두 다르기 때문에 연속된 공간에 할당하는 것은 불가능하다.

~~~
1. 파이썬의 모든 것은 객체이다. 
2. 객체들은 연결 리스트 형태로 연결되어 있다.
3. 연결 리스트에 대한 포인터 목록을 배열 형태로 관리한다.
~~~

---

## 딕셔너리

* 키/값 구조를 가진 자료형
* 내부적으로 해시 테이블로 구현되어 있다.
* 다양한 타입으로 키를 설정할 수 있다. cf) 리스트의 경우 인덱스는 숫자여야 한다.
* 해싱: 딕셔너리는 해시할 수 있으면 문자, 집합 까지 모든 불변 객체를 모두 키로 사용 가능하다.
* 해시 테이블을 이용해 자료를 저장한다.
* 대부분의 연산이 O(1)에 처리 가능하다.
* 3.7+ 버전에서는 입력 순서가 유지된다. 

|연산|시간 복잡도|설명|
|--|--|--|
|len(a)|O(1)|요소의 개수를 리턴|
|a[key]|O(1)|키를 조회하여 값을 리턴|
|a[key] = value|O(1)|키/값을 삽입한다.|
|key in a|O(1)|딕셔너리에 키가 존재하는지 확인한다.|

### 딕셔너리 활용

* 선언
~~~
a = dict()
a = {}
~~~

* 키/값 초기화
~~~
# 초기값으로 지정하여 선언
a = {'key1':'value1', 'key2':'value2'}
a  ## {'key1':'value1', 'key2':'value2'}

# 별도로 선언
a['key3'] = 'value3'
a  ## {'key1':'value1', 'key2':'value2', 'key3':'value3'}
~~~

* 키를 통해 값 조회

~~~
a['key1']  ## 'value1'
~~~

* 존재하지 않는 값에 대한 예외 처리

~~~
# 존재하지 않는 값 접근
try: 
    print(a['key4'])
except KeyError:
    print("존재하지 않는 키")
    
# 존재하지 않는 값 삭제
try: 
    del a['key4']
except KeyError:
    print("존재하지 않는 키")
    
# 존재하지 않는 값 if로 확인
if 'key4' in a
    print('존재하는 키')
else:
    print('존재하지 않는 키')
~~~

* for 문을 통한 딕셔너리 출력

~~~
# item 함수: 딕셔너리의 키와 값을 각각 꺼내온다.
for k, v in a.item():
    print(k, v)
~~~

* 삭제 키워드 del

~~~
del a['key1']
a  ##{'key2':'value2', 'key3':'value3'}
~~~

## 딕셔너리 모듈

* 딕셔너리와 관련된 특수한 컨테이너 자료형

### defaultdict 객체

* 존재하지 않는 키에 대한 값을 조회 할 때 에러 메시지 대신 디폴트 값 0을 할당한다.

~~~
b = collections.defaultdict(int)
b['A'] = 1
b['B'] = 2
b  ## defaultdict(int, {'A': 1, 'B': 2})

b['C'] += 1  
b  ## defaultdict(int, {'A': 1, 'B': 2, 'C':1})

b['D']
b  ## defaultdict(int, {'A': 1, 'B': 2, 'C':1, 'D':0})
~~~

### Counter 객체

* 딕셔너리 요소의 개수를 세어준다.
* ('키':값) -> (값 : 개수)

~~~
a = [1,2,3,4,5,5,5,6,6]
b = collections.Counter(a)
b  ## Counter({1: 1, 2: 1, 3: 1, 4: 1, 5: 3, 6: 2})
~~~

* Counter 객체에서 빈도수가 높은 요소 가져오기

~~~
## 파라미터 -> 가장 높은 것 부터 개수
b.most_common(2)  ## [(5, 3), (6, 2)]
~~~

### Overdict 객체

* 딕셔너리의 입력 순서를 유지시킨다.

~~~
collections.Overdict({'banana':3, 'apple': 4, 'peer': 1, 'orange': 2})
~~~

#### 타입 선언 방법

~~~
# 이름 지정
a = list()

# 기호 사용
a = []

type([])  ##<class 'list'>
type(())  ##<class 'tuple'>
type({})  ##<class 'dict'>
type({1})  ##<class 'set'>
~~~

