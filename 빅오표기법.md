# 빅오

## 시간 복잡도

* 어떤 알고리즘을 수행하는 데 걸리는 시간을 설명하는 계산 복잡도이다. -> 입력값 개수에 따라 발생하는 연산 횟수를 기준으로 걸리는 시간을 파악한다. 
* 점근적 실행 시간이라고도 한다.
* 계산 복잡도를 표기하는 대표적인 방법이 빅오이다. -> 의미상 시간 복잡도, 계산 복잡도, 빅오를 모두 같은 의미로 사용할 수 있다.
* 입력 개수에 따른 연산 횟수로 함수 형태이다.

---

## 빅오 

* 빅오란 입력값이 무한대로 향할때 함수의 상한을 설명하는 수학적 표기법이다.
* 시간 복잡도를 빅오로 표기할 시 최고차항만 표기되며 상수항음 무시된다.
* 시간 복잡도 뿐만아니라 공간 복잡도도 나타낸다. 

### 종류별 빅오 표기법

#### O(1)

* 입력값이 아무리 커도 실행 시간이 일정하다.
* 상수값이 너무 크게되면 사실사 일정한 시간의 의미가 없다.
* 해시 테이블의  조회 및 삽입이 이에 해당한다.

#### O(logn)

* 큰 입력값에도 크게 영향을 받지 않는 편으로 웬만한 n의 크기에 대해서도 매우 견고하다.
* 이진 검색이 이에 해당된다.

#### O(n)

* 알고리즘을 수행하는 데 걸리는 시간이 입력값에 비례한다.
* 선형 시간 알고리즘이라고 한다. 
* 정렬되지 않은 리스트에서 최댓값, 최솟값을 찾는 경우가 이에 해당된다. -> 적어도 한 번 이상 모든 입력값들을 살펴봐야 한다.

#### O(nlogn)

* 병합 정렬이 해당된다.
* 적어도 한 번 이상 비교해야 하는 비교 기반 정렬 알고리즘은 해당 복잡도보다 빠를 수 없다.
* 입력값이 최선인 경우 비교를 건너 뛰어 O(n)이 될 수 있다.

#### O(n^2)

* 버블 정렬(비효율)이 해당된다.

#### O(2^n)

* 외판원 문제(도시를 방문하고 돌아오는 가장 짧은 경로를 찾는 것)가 이에 해당된다.
* 가장 느린 알고리즘으로 입력값이 조금만 커져도 웬만한 다항시간 내에는 계산이 어렵다. 

### 컴퓨터에서 시간과 공간

* 시간과 공간은 트레이드오프 관계이다. -> 실행 시간이 빠른 알고리즘은 공간을 많이 사용하고, 공간을 적게 차지하는 알고리즘은 실행 시간이 느리다.
* 실행 시간이 빠르면서 공간을 적게 차지하는 알고리즘이 드물게 존재하기도한다. 

### 빅오 표기법과 최악의 경우/평균적인 경우/ 최선의 경우 시간 복잡도

* 빅오 표기법의 경우 입력값에 따른 연산의 개수와 관련되어 있다. 
* 최악, 평균, 최선 경우의 개념은 자료자체의 구성과 관련된다.
* 상한과 하한은 알고리즘에서 단순히 입력 크기에 따른 연산 개수를 세어 최대치와 최소치를 나타낸 것이다.
* 최악, 최선의 경우 시간 복잡도는 입력 크기에 상관없이 자료의 구성으로 설명된다. 
-> 특정 알고리즘에 부적합한 입력 자료들은 최악 경우의 시간 복잡도를 가지고 적합한 경우 최선 경우의 시간 복잡도를 가지게 된다. 

--

## 분할 상환 분석

* 최악의 경우를 여러 번에 걸쳐 골고루 나눠주는 형태로 알고리즘의 시간 복잡도를 계산하는 방법
* 시간 또는 메모리를 분석하는 알고리즘의 복잡도를 계산할 때 알고리즘 전체를 보지 않고 최악의 경우만 살피는 것은 비관적이다.
-> 모든 경우마다 최악의 경우를 염두하면 정확하지도 않고 비관적이다. 
* 동적 배열로 예를 들면 더즐링이 매번 일어난다고 가정하는 것과 마찬가지이다.

---

## 병렬화

### GPU 

* 병렬 연산을 위한 대표적 장치
* 각가의 코어는 CPU 보다 느리지만 보다 많은 개수를 가지고 있다. -> 수천여 개로 구성된다.
* CPU는 작업을 빠르게 처리하기위해 설계되었으며 명령어 하나로 처리할 수 있는 기능이 많다. 







